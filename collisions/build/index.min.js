function satCollision(e,t){const o=[...e.edges.map((e=>createVector(-e.y,e.x).normalize())),...t.edges.map((e=>createVector(-e.y,e.x).normalize()))];let s=1/0;for(let i=0;i<o.length;i++){normal=o[i];let l=1/0,n=-1/0;e.vertices.forEach((e=>{l=min(l,p5.Vector.dot(normal,e)),n=max(n,p5.Vector.dot(normal,e))}));let r=1/0,c=-1/0;if(t.vertices.forEach((e=>{r=min(r,p5.Vector.dot(normal,e)),c=max(c,p5.Vector.dot(normal,e))})),r>n||c<l)return null;s=min(s,min(n,c)-max(l,r))}return t.centre.copy().sub(e.centre).normalize().mult(s)}function staticResolve(e,t,o){let s=o.copy().mult(.5),i=o.copy().mult(-.5),l=o.copy().mult(-1),n=e.movable,r=t.movable,c=e.mass,a=t.mass,h=c+a;n&&r?(e.moveBy(i.mult(a/h)),t.moveBy(s.mult(c/h))):n?e.moveBy(l):r&&t.moveBy(o)}const primaryColor="#fff4d6",secondaryColor="#908a76";class Polygon{constructor(e,t,o,s,i,l,n){this.mass=s,this.color=n?"#908a76":color(50),this.defaultColor=this.color,this.movable=n,this.controllable=l,this.maxSpeed=i,this.facingDir=createVector(0,0),this.centre=e,this.distFromCentre=o,this.numVertices=t,this.createShape(t),this.displacement=createVector(0,0)}createShape(){let e=[],t=2*PI/this.numVertices,o=0,s=this.controllable?0:t;for(let i=0;i<this.numVertices;i++)e.push(random(o,s)),o+=t,s+=t;this.vertices=[];for(let t=0;t<this.numVertices;t++){let o=createVector(this.centre.x+this.distFromCentre*cos(e[t]),this.centre.y+this.distFromCentre*sin(e[t]));this.vertices.push(o)}this.facingDir=this.vertices[0].copy().sub(this.centre).normalize(),this.calculateEdges()}calculateEdges(){this.edges=[];for(let e=0;e<this.vertices.length;e++){let t=(e+1)%this.vertices.length;this.edges.push(this.vertices[t].copy().sub(this.vertices[e]))}}draw(){stroke("#fff4d6"),strokeWeight(3),fill(this.color),beginShape();for(let e=0;e<this.numVertices;e++)vertex(this.vertices[e].x,this.vertices[e].y);endShape(CLOSE),this.controllable&&line(this.centre.x,this.centre.y,this.vertices[0].x,this.vertices[0].y)}move(){let e=0,t=0;keyIsDown(87)&&(e+=this.maxSpeed),keyIsDown(83)&&(e-=this.maxSpeed),keyIsDown(65)&&(t-=PI/48),keyIsDown(68)&&(t+=PI/48);let o=this.facingDir.copy().mult(e);this.centre.add(o);for(let e=0;e<this.vertices.length;e++){let s=this.vertices[e];s.add(o),s.sub(this.centre).rotate(t).add(this.centre)}this.facingDir=this.vertices[0].copy().sub(this.centre).normalize(),this.calculateEdges()}moveBy(e){this.centre.add(e);for(let t=0;t<this.vertices.length;t++)this.vertices[t].add(e);this.calculateEdges()}update(){this.draw()}colliding(){this.movable&&!this.controllable&&(this.color=color("#fff4d6"))}notColliding(){this.color=this.defaultColor}}const bgColor="#070831";let polygonCount=10,polygons=[],controllablePolygon=null;function windowResized(){background(bgColor)}function setup(){createCanvas(windowWidth,windowHeight),polygons.push(new Polygon(createVector(300,300),5,100,100,3,!0,!0));for(let e=1;e<polygonCount;e++)polygons.push(new Polygon(createVector(random(0,windowWidth),random(0,windowHeight)),Math.floor(random(3,10)),random(50,100),random(5,100),random(5,10),!1,!0));controllablePolygon=polygons[0]}function draw(){background(bgColor);for(let e of polygons)e.update();collisionCheck(),controllablePolygon.move()}function collisionCheck(){let e=new Set;for(let t=0;t<polygonCount;t++){polygons[t].notColliding();for(let o=t+1;o<polygonCount;o++){let s=satCollision(polygons[t],polygons[o]);s&&(e.add(t),e.add(o),collisionResolution(polygons[t],polygons[o],s))}}e.forEach((e=>polygons[e].colliding()))}function collisionResolution(e,t,o){staticResolve(e,t,o)}